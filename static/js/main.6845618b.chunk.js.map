{"version":3,"sources":["fsm.ts","components/MachineSimulator.tsx","pages/Minimizer.tsx","pages/Simulator.tsx","App.tsx","index.tsx"],"names":["PATTERNS","STATES","INITIAL","ACCEPTING","ALPHABET","TRANSITIONS","StateMachine","options","multigraph","initial","alphabet","Set","accepted","setGraph","rankdir","input","node","this","testInput","undefined","has","name","label","add","setNode","v","w","symbol","edge","symbols","includes","setEdge","edges","t","nodes","length","desc","join","size","transitions","map","flatMap","c","R","reachable","F","setIntersect","Q","setDiff","P","W","A","pop","X","transition","state","Y","diff","intr","splice","indexOf","push","K","filter","p","names","Map","M","forEach","k","s","set","get","setAccepted","peripheries","outEdges","e","setTransition","setInitial","setSymbol","found","start","queue","visited","current","a","b","value","description","build","parse","digraph","states","accept","Error","some","Graph","parse_initial","parse_states","parse_accepting","parse_alphabet","parse_transitions","statesMatch","exec","split","trim","initialMatch","acceptMatch","alphabetMatch","transMatch","matchAll","MachineSimulator","minimize","props","useState","error","setError","parsed","setParsed","useEffect","graph","fsm","finalNode","fillcolor","style","output","dot","write","read","message","Graphviz","defaultProps","Minimizer","setDescription","minimized","setMinimized","machine","console","log","Container","Row","Col","InputGroup","height","Prepend","Text","FormControl","as","aria-label","onChange","target","disabled","Simulator","setInput","isAccepted","App","Navbar","className","maxWidth","collapseOnSelect","expand","variant","Brand","Link","to","Toggle","aria-controls","Collapse","id","Nav","NavLink","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6845618b.chunk.js","sourcesContent":["import { Edge, Graph, GraphOptions } from \"graphlib\";\n\nconst PATTERNS = {\n    STATES: /:states:\\s*((\\w+\\s*)+)/,\n    INITIAL: /:initial:\\s*(\\w+)\\s*/,\n    ACCEPTING: /:accept:\\s*((\\w+\\s*)+)/,\n    ALPHABET: /:alphabet:\\s*((\\w\\s*)+)/,\n    TRANSITIONS: /:transitions:\\n((\\w+\\s*,\\s*\\w+\\s*>\\s*\\w+\\n?)*)/\n}\n\n/**\n * JSON compatible description of a {@link StateMachine}\n */\nexport interface StateMachineDescription {\n    states: string[],\n    initial: string;\n    accept?: string[];\n    alphabet: string[];\n    transitions?: Array<[string, string, string]>;\n}\n\nexport interface StateMachineOptions extends GraphOptions {\n    description?: string | StateMachineDescription;\n}\n\ninterface Transition extends Edge {\n}\n\n/**\n * Graph representation of a finite state machine.\n */\nexport class StateMachine extends Graph {\n    private initial!: string;\n\n    private alphabet: Set<string> = new Set();\n    private accepted: Set<string> = new Set();\n\n    public constructor(options?: StateMachineOptions) {\n        super({ ...options, multigraph: true });\n\n        this.setGraph({ rankdir: \"LR\" })\n    }\n\n    /**\n     * Construct a new {@link StateMachine} from a string or JSON representation.\n     * @param {string|StateMachineDescription} description\n     * @returns {StateMachine}\n     */\n    public static parse(description: string | StateMachineDescription): StateMachine {\n        if (typeof description === \"string\") {\n            return this.build(parse(description));\n        } else {\n            return this.build(description);\n        }\n    }\n\n    /**\n     * Check if an input string is accepted by the {@link StateMachine}\n     * @param {string} input\n     * @returns {boolean}\n     */\n    public isAccepted(input: string): boolean {\n        const node = this.testInput(input);\n        return node !== undefined && this.accepted.has(node);\n    }\n\n    /**\n     * Set the initial state on the state machine.\n     * @param initial\n     */\n    public setInitial(initial: string): this {\n        this.initial = initial;\n\n        return this;\n    }\n\n    /**\n     * Set a state as accepted on the state machine.\n     * @param name\n     * @param label\n     */\n    public setAccepted(name: string, label: any): this {\n        this.accepted.add(name);\n\n        return this.setNode(name, label) as this;\n    }\n\n    /**\n     * Add a symbol to the state machine's alphabet.\n     * @param name\n     * @param label\n     */\n    public setSymbol(name: string, label: any): this {\n        this.alphabet.add(name);\n\n        return this;\n    }\n\n    /**\n     * Add a transition to the state machine.\n     * @param {string} v The starting state.\n     * @param {string} w The ending state.\n     * @param {string} symbol The symbol for which the transition occurs.\n     */\n    public setTransition(v: string, w: string, symbol: string): this {\n        const edge = this.edge(v, w) as { label: string, symbols: string[] };\n\n        if (edge) {\n            if (edge.symbols.includes(symbol)) {\n                return this;\n            } else {\n                return this.setEdge(v, w, { label: `${edge.label},${symbol}`, symbols: [...edge.symbols, symbol] }) as this;\n            }\n        }\n\n        return this.setEdge(v, w, { label: symbol, symbols: [symbol] }) as this;\n    }\n\n    /**\n     * Retrieve all transitions on the StateMachine.\n     * Alias for {@link StateMachine.edges}\n     * @returns {Transition[]}\n     */\n    public transitions(): Transition[] {\n        return this.edges();\n    }\n\n    /**\n     * Retrieve the data associated with a transition.\n     * Alias for {@link StateMachine.edge}\n     * @param {Transition} t\n     */\n    public transition(t: Transition): Transition {\n        return this.edge(t);\n    }\n\n    /**\n     * Build the textual description of this machine.\n     * This can be used for debugging or constructing other machines.\n     * @returns {string}\n     */\n    public description(): string {\n        if (this.nodes().length === 0) return \"\";\n\n        let desc = \"\";\n        desc += `:states:\\n${this.nodes().join(\"\\n\")}\\n`;\n        desc +=  `:initial:\\n${this.initial}\\n`;\n\n        if (this.accepted.size > 0) {\n            desc += `:accept:\\n${[...this.accepted].join(\"\\n\")}\\n`;\n        }\n\n        if (this.alphabet.size > 0) {\n            desc += `:alphabet:\\n${[...this.alphabet].join(\"\\n\")}\\n`;\n        }\n\n        if (this.transitions().length > 0) {\n            desc += `:transitions:\\n${\n                this.transitions()\n                  .map(t => ({ v: t.v, w: t.w, symbols: this.edge(t).symbols}))\n                  .flatMap(t => t.symbols.map((c: string) => `${t.v}, ${c} > ${t.w}`))\n                  .join(\"\\n\")\n            }\\n`;\n        }\n\n        return desc;\n    }\n\n    /**\n     * Implementation of Hopcroft's algorithm\n     * https://en.wikipedia.org/wiki/DFA_minimization\n     * @returns {StateMachine} A new {@link StateMachine}\n     */\n    public minimize(): StateMachine {\n        const R = this.reachable();\n        const F = this.setIntersect(this.accepted, R);\n        const Q = this.setIntersect(this.setDiff(new Set(this.nodes()), F), R);\n\n        let P = [F, Q];\n        let W = [F, Q];\n\n        while (W.length > 0) {\n            const A = W.pop()!;\n\n            for (const c of this.alphabet) {\n                const X = new Set<string>();\n\n                for (const transition of this.transitions()) {\n                    const attrs = this.edge(transition);\n                    if (attrs.symbols.includes(c)) {\n                        for (const state of A) {\n                            if (transition.w === state) {\n                                X.add(transition.v);\n                            }\n                        }\n                    }\n                }\n\n                P = P.flatMap(Y => {\n                    const diff = this.setDiff(Y, X);\n                    const intr = this.setIntersect(X, Y);\n                    if (diff.size > 0 && intr.size > 0) {\n                        if (W.includes(Y)) {\n                            W.splice(W.indexOf(Y), 1);\n\n                            W.push(intr, diff);\n                        } else {\n                            W.push(intr.size <= diff.size ? intr : diff);\n                        }\n\n                        return [intr, diff];\n                    } else {\n                        return Y;\n                    }\n                });\n            }\n        }\n\n        const K = P.filter(p => p.size > 0);\n        const names = new Map<string, string>();\n\n        const M = new StateMachine({ multigraph: true });\n\n        K.forEach(k => {\n            const name = [...k].join(\"\");\n            k.forEach(s => names.set(s, name));\n        });\n\n        K.forEach(k => {\n            const s = [...k][0];\n\n            M.setNode(names.get(s)!);\n\n            if (this.accepted.has(s)) {\n                M.setAccepted(names.get(s)!, { peripheries: 2 })\n            }\n\n            (this.outEdges(s) as Edge[]).forEach(e => {\n                this.edge(e).symbols.forEach((c: string) => {\n                    M.setTransition(names.get(s)!, names.get(e.w)!, c);\n                });\n            });\n        });\n\n        M.setInitial(names.get(this.initial)!);\n\n        [...this.alphabet].forEach(c => M.setSymbol(c, {}))\n\n        return M;\n    }\n\n    public testInput(input: string): string | undefined {\n        let node = this.initial;\n\n        for (const c of input) {\n            if (!this.alphabet.has(c)) {\n                return undefined;\n            }\n\n            const edges = this.outEdges(node);\n\n            let found = false;\n            if (edges) {\n                for (const e of edges) {\n                    const edge = this.edge(e);\n\n                    if (edge.symbols.includes(c)) {\n                        node = e.w;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!found) {\n                return node;\n            }\n        }\n\n        return node;\n    }\n\n    private static build(description: StateMachineDescription): StateMachine {\n        const digraph = new StateMachine();\n\n        const { states, initial, accept, alphabet, transitions } = description;\n\n        if (!states) {\n            return digraph;\n        }\n\n        if (!initial) {\n            throw new Error(\"Cannot parse StateMachine with no initial state!\");\n        } else {\n            if (!states.includes(initial)) {\n                throw new Error(\"Initial state set to a state that does not exist!\");\n            }\n        }\n\n        if (accept && accept.length > 0 && accept.some(s => !states.includes(s))) {\n            throw new Error(\"Accepted states includes a state that does not exist!\");\n        }\n\n        if (transitions && transitions.length > 0) {\n            if (!alphabet || alphabet.length === 0) {\n                throw new Error(\"Cannot specify transitions with an empty alphabet!\");\n            }\n\n            if (transitions.some(t => !alphabet.includes(t[1]))) {\n                throw new Error(\"Transition includes a symbol which is not defined in the alphabet!\");\n            }\n\n            if (transitions.some(t => !states.includes(t[0]) || !states.includes(t[2]))) {\n                throw new Error(\"Transition includes a state which is not defined in states!\");\n            }\n        }\n\n        (alphabet || []).forEach(c => digraph.setSymbol(c, {}));\n        states.forEach(s => digraph.setNode(s));\n        digraph.setInitial(initial);\n        (accept || []).forEach(s => digraph.setAccepted(s, { peripheries: 2 }));\n        (transitions || []).forEach(t => digraph.setTransition(t[0], t[2], t[1]));\n\n        return digraph\n    }\n\n    private reachable(): Set<string> {\n        const start = this.initial;\n        const queue = [start];\n        const visited = new Set([start]);\n\n        while (queue.length > 0) {\n            const current = queue.pop();\n\n            for (const transition of this.transitions()) {\n                if (current === transition.v) {\n                    if (!visited.has(transition.w)) {\n                        visited.add(transition.w);\n\n                        if (!queue.includes(transition.w)) {\n                            queue.push(transition.w);\n                        }\n                    }\n                }\n            }\n        }\n\n        return visited;\n    }\n\n    private setDiff<T>(a: Set<T>, b: Set<T>): Set<T> {\n        return new Set([...a].filter(value => !b.has(value)));\n    }\n\n    private setIntersect<T>(a: Set<T>, b: Set<T>): Set<T> {\n        return new Set([...a].filter(value => b.has(value)));\n    }\n}\n\nexport const parse = (input: string): StateMachineDescription => {\n    const initial = parse_initial(input)!;\n    const states = parse_states(input)!;\n    const accept = parse_accepting(input);\n    const alphabet = parse_alphabet(input);\n    const transitions = parse_transitions(input);\n\n    return { initial, states, accept, alphabet, transitions };\n}\n\nconst parse_states = (input: string): string[] | null => {\n    const statesMatch = PATTERNS.STATES.exec(input);\n    return statesMatch && statesMatch[1] ? statesMatch[1].split(/\\s+/).map(s => s.trim()).filter(s => s !== \"\") : null;\n}\n\nconst parse_initial = (input: string): string | null => {\n    const initialMatch = PATTERNS.INITIAL.exec(input);\n\n    return initialMatch && initialMatch[1] ? initialMatch[1] : null;\n}\n\nconst parse_accepting = (input: string): string[] => {\n    const acceptMatch = PATTERNS.ACCEPTING.exec(input);\n    return acceptMatch && acceptMatch[1] ? acceptMatch[1].split(/\\s+/).map(s => s.trim()).filter(s => s !== \"\") : [];\n}\n\nconst parse_alphabet = (input: string): string[] => {\n    const alphabetMatch = PATTERNS.ALPHABET.exec(input);\n    return alphabetMatch && alphabetMatch[1] ? alphabetMatch[1].split(/\\s*/).map(c => c.trim()).filter(c => c !== \"\") : [];\n};\n\nconst parse_transitions = (input: string): [string, string, string][] => {\n    const transMatch = PATTERNS.TRANSITIONS.exec(input);\n\n    if (!transMatch) {\n        return [];\n    }\n\n    return [...transMatch[1].matchAll(/(\\w+)\\s*,\\s*(\\w+)\\s*>\\s*(\\w+)/g)].map(t => {\n        return [t[1], t[2], t[3]];\n    });\n}\n","import React, { FunctionComponent, useState, useEffect } from 'react';\nimport { Graphviz, IGraphvizProps } from 'graphviz-react';\n\nimport dot from \"graphlib-dot\";\nimport {StateMachine, StateMachineDescription} from '../fsm';\n\ninterface Props extends Omit<IGraphvizProps, \"dot\"> { minimize?: boolean; description: string | StateMachineDescription; input?: string | null; }\n\nexport const MachineSimulator: FunctionComponent<Props> = ({ minimize, description, input, ...props }) => {\n    const [error, setError] = useState(\"\");\n    const [parsed, setParsed] = useState<string | null>(null);\n\n    useEffect(() => {\n        try {\n            const graph = StateMachine.parse(description);\n            const fsm = minimize ? graph.minimize() : graph;\n\n            if (input !== null) {\n                const finalNode = fsm.testInput(input || \"\");\n                if (finalNode) {\n                    const node = fsm.node(finalNode);\n                    fsm.setNode(finalNode, { ...node, fillcolor: \"#f54f4c\", style: \"filled\" });\n                }\n            }\n\n            const output = minimize ? dot.write(graph.minimize()) : dot.write(graph);\n            dot.read(output);\n            setParsed(output);\n            setError('');\n        } catch (e) {\n            setError(`${e.name}: ${e.message}`);\n            setParsed(null);\n        }\n\n        return () => {\n            setParsed(null);\n        }\n    }, [description, minimize, input])\n\n    return (\n        parsed ? <Graphviz dot={parsed} {...props}/> : <div>{error}</div>\n    )\n}\n\nMachineSimulator.defaultProps = {\n    minimize: false,\n    input: null\n}\n","import React, {useEffect, useState} from 'react';\nimport {Container, Row, Col, InputGroup, FormControl} from 'react-bootstrap';\n\nimport { MachineSimulator } from '../components';\nimport {StateMachine} from \"../fsm\";\n\nconst DEFAULT_MACHINE = `:states:\na\nb\n:initial:\na\n:accept:\nb\na\n:alphabet:\n0\n1\n:transitions:\na, 0 > b\na, 1 > b\nb, 0 > b\nb, 1 > a`;\n\nexport const Minimizer = () => {\n  const [description, setDescription] = useState<string>(DEFAULT_MACHINE);\n    const [minimized, setMinimized] = useState<string>(\"\");\n\n    useEffect(() => {\n      try {\n        const machine = StateMachine.parse(description).minimize();\n        console.log(machine);\n        setMinimized(machine.description());\n      } catch {\n        setMinimized({} as any)\n      }\n    }, [description])\n\n    return (\n        <Container>\n          <h1>DFA Minimizer</h1>\n          <Row>\n            <Col>\n              <Container>\n                <Row>\n                  <h2>Input Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Input</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl value={description} as={\"textarea\"} aria-label=\"input\" onChange={(e) => setDescription(e.target.value)} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <h2>Input Machine</h2>\n                  <MachineSimulator description={description} options={{ height: 200 }} />\n                </Row>\n              </Container>\n            </Col>\n            <Col>\n              <Container>\n                <Row>\n                  <h2>Minimized Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Input</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl disabled as={\"textarea\"} value={minimized} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <h2>Output Machine</h2>\n                  <MachineSimulator description={description} minimize options={{ height: 200 }} />\n                </Row>\n              </Container>\n            </Col>\n          </Row>\n        </Container>\n    )\n}\n","import React, {useEffect, useState} from 'react';\nimport {Container, InputGroup, FormControl, Row, Col} from 'react-bootstrap';\n\nimport { MachineSimulator } from '../components';\nimport {StateMachine} from \"../fsm\";\n\nexport const Simulator = () => {\n    const [description, setDescription] = useState<string>(\"\");\n    const [input, setInput] = useState(\"\");\n    const [accepted, setAccepted] = useState(false);\n\n    useEffect(() => {\n        try {\n            const machine = StateMachine.parse(description);\n            console.log(machine);\n            setAccepted(machine.isAccepted(input));\n        } catch {\n            setAccepted(false);\n        }\n    }, [description, input]);\n\n    return (\n      <Container>\n          <h1>DFA Simulator</h1>\n          <Row>\n              <Col>\n                  <h2>Input Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Input</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl as={\"textarea\"} aria-label=\"input\" onChange={(e) => setDescription(e.target.value)} />\n                  </InputGroup>\n              </Col>\n              <Col>\n                  <h2>Simulate Input</h2>\n                  <InputGroup>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Input</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl aria-label=\"input\" onChange={(e) => setInput(e.target.value)} />\n                  </InputGroup>\n                  <br/>\n                  <h4>Input is {accepted ? \"ACCEPTED\" : \"NOT ACCEPTED\"}.</h4>\n                  <MachineSimulator description={description} input={input} options={{ height: 200 }} />\n              </Col>\n          </Row>\n      </Container>\n    )\n}\n","import React from 'react';\nimport { Nav, Navbar } from 'react-bootstrap';\n\nimport { BrowserRouter as Router, Link, NavLink, Route, Switch } from \"react-router-dom\";\nimport { Simulator, Minimizer } from './pages';\n\nfunction App() {\n  return (\n    <Router>\n      <header>\n        <Navbar className=\"mx-auto\" style={{ maxWidth: \"1150px\" }} collapseOnSelect expand=\"lg\" variant=\"light\">\n          <Navbar.Brand as={Link} to=\"/\">FSM Tools</Navbar.Brand>\n          <Navbar.Toggle aria-controls=\"responsive-navbar-nav\"/>\n          <Navbar.Collapse id=\"responsive-navbar-nav\">\n              <Nav className=\"mr-auto\">\n                  <Nav.Link className=\"text-secondary\" as={NavLink} to=\"/simulator\">Simulator</Nav.Link>\n                  <Nav.Link className=\"text-secondary\" as={NavLink} to=\"/minimizer\">Minimizer</Nav.Link>\n              </Nav>\n          </Navbar.Collapse>\n        </Navbar>\n      </header>\n      <main>\n        <Switch>\n          <Route path=\"/simulator\">\n            <Simulator/>\n          </Route>\n          <Route path=\"/minimizer\">\n            <Minimizer/>\n          </Route>\n        </Switch>\n      </main>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}