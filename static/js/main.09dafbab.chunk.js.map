{"version":3,"sources":["fsm.ts","components/MachineSimulator.tsx","pages/Minimizer.tsx","pages/Simulator.tsx","pages/Home.tsx","App.tsx","index.tsx"],"names":["PATTERNS","STATES","INITIAL","ACCEPTING","ALPHABET","TRANSITIONS","StateMachine","options","multigraph","initial","alphabet","Set","accepted","setGraph","rankdir","input","node","this","testInput","undefined","has","name","label","add","setNode","v","w","symbol","edge","symbols","includes","setEdge","edges","t","btoa","minimize","description","nodes","length","desc","join","size","transitions","map","flatMap","c","R","reachable","F","setIntersect","Q","setDiff","P","W","A","pop","X","transition","state","Y","diff","intr","splice","indexOf","push","K","filter","p","names","Map","M","forEach","k","s","set","get","setAccepted","peripheries","outEdges","e","setTransition","setInitial","setSymbol","found","start","queue","visited","current","a","b","value","build","parse","digraph","states","accept","Error","some","Graph","parse_initial","parse_states","parse_accepting","parse_alphabet","parse_transitions","statesMatch","exec","split","trim","initialMatch","acceptMatch","alphabetMatch","transMatch","matchAll","MachineSimulator","props","useState","error","setError","parsed","setParsed","useEffect","graph","fsm","finalNode","fillcolor","style","output","dot","write","read","message","Graphviz","defaultProps","Minimizer","setDescription","minimized","setMinimized","hash","setHash","minimizedHash","setMinimizedHash","base","machine","Container","Row","Col","InputGroup","height","Prepend","Text","FormControl","as","aria-label","onChange","target","width","disabled","Simulator","DEFAULT_MACHINE","setInput","isAccepted","Home","to","App","basename","Navbar","className","maxWidth","collapseOnSelect","expand","variant","Brand","Link","Toggle","aria-controls","Collapse","id","Nav","NavLink","path","exact","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.09dafbab.chunk.js","sourcesContent":["import { Edge, Graph, GraphOptions } from \"graphlib\";\n\nconst PATTERNS = {\n    STATES: /:states:\\s*((\\w+\\s*)+)/,\n    INITIAL: /:initial:\\s*(\\w+)\\s*/,\n    ACCEPTING: /:accept:\\s*((\\w+\\s*)+)/,\n    ALPHABET: /:alphabet:\\s*((\\w\\s*)+)/,\n    TRANSITIONS: /:transitions:\\n((\\w+\\s*,\\s*\\w+\\s*>\\s*\\w+\\n?)*)/\n}\n\n/**\n * JSON compatible description of a {@link StateMachine}\n */\nexport interface StateMachineDescription {\n    states: string[],\n    initial: string;\n    accept?: string[];\n    alphabet: string[];\n    transitions?: Array<[string, string, string]>;\n}\n\nexport interface StateMachineOptions extends GraphOptions {\n    description?: string | StateMachineDescription;\n}\n\ninterface Transition extends Edge {\n}\n\n/**\n * Graph representation of a finite state machine.\n */\nexport class StateMachine extends Graph {\n    private initial!: string;\n\n    private alphabet: Set<string> = new Set();\n    private accepted: Set<string> = new Set();\n\n    public constructor(options?: StateMachineOptions) {\n        super({ ...options, multigraph: true });\n\n        this.setGraph({ rankdir: \"LR\" })\n    }\n\n    /**\n     * Construct a new {@link StateMachine} from a string or JSON representation.\n     * @param {string|StateMachineDescription} description\n     * @returns {StateMachine}\n     */\n    public static parse(description: string | StateMachineDescription): StateMachine {\n        if (typeof description === \"string\") {\n            return this.build(parse(description));\n        } else {\n            return this.build(description);\n        }\n    }\n\n    /**\n     * Check if an input string is accepted by the {@link StateMachine}\n     * @param {string} input\n     * @returns {boolean}\n     */\n    public isAccepted(input: string): boolean {\n        const node = this.testInput(input);\n        return node !== undefined && this.accepted.has(node);\n    }\n\n    /**\n     * Set the initial state on the state machine.\n     * @param initial\n     */\n    public setInitial(initial: string): this {\n        this.initial = initial;\n\n        return this;\n    }\n\n    /**\n     * Set a state as accepted on the state machine.\n     * @param name\n     * @param label\n     */\n    public setAccepted(name: string, label: any): this {\n        this.accepted.add(name);\n\n        return this.setNode(name, label) as this;\n    }\n\n    /**\n     * Add a symbol to the state machine's alphabet.\n     * @param name\n     * @param label\n     */\n    public setSymbol(name: string, label: any): this {\n        this.alphabet.add(name);\n\n        return this;\n    }\n\n    /**\n     * Add a transition to the state machine.\n     * @param {string} v The starting state.\n     * @param {string} w The ending state.\n     * @param {string} symbol The symbol for which the transition occurs.\n     */\n    public setTransition(v: string, w: string, symbol: string): this {\n        const edge = this.edge(v, w) as { label: string, symbols: string[] };\n\n        if (edge) {\n            if (edge.symbols.includes(symbol)) {\n                return this;\n            } else {\n                return this.setEdge(v, w, { label: `${edge.label},${symbol}`, symbols: [...edge.symbols, symbol] }) as this;\n            }\n        }\n\n        return this.setEdge(v, w, { label: symbol, symbols: [symbol] }) as this;\n    }\n\n    /**\n     * Retrieve all transitions on the StateMachine.\n     * Alias for {@link StateMachine.edges}\n     * @returns {Transition[]}\n     */\n    public transitions(): Transition[] {\n        return this.edges();\n    }\n\n    /**\n     * Retrieve the data associated with a transition.\n     * Alias for {@link StateMachine.edge}\n     * @param {Transition} t\n     */\n    public transition(t: Transition): Transition {\n        return this.edge(t);\n    }\n\n    /**\n     * A unique hash based on the description of the machine.\n     */\n    public hash(): string {\n        return btoa(this.minimize().description());\n    }\n\n    /**\n     * Build the textual description of this machine.\n     * This can be used for debugging or constructing other machines.\n     * @returns {string}\n     */\n    public description(): string {\n        if (this.nodes().length === 0) return \"\";\n\n        let desc = \"\";\n        desc += `:states:\\n${this.nodes().join(\"\\n\")}\\n`;\n        desc +=  `:initial:\\n${this.initial}\\n`;\n\n        if (this.accepted.size > 0) {\n            desc += `:accept:\\n${[...this.accepted].join(\"\\n\")}\\n`;\n        }\n\n        if (this.alphabet.size > 0) {\n            desc += `:alphabet:\\n${[...this.alphabet].join(\"\\n\")}\\n`;\n        }\n\n        if (this.transitions().length > 0) {\n            desc += `:transitions:\\n${\n                this.transitions()\n                  .map(t => ({ v: t.v, w: t.w, symbols: this.edge(t).symbols}))\n                  .flatMap(t => t.symbols.map((c: string) => `${t.v}, ${c} > ${t.w}`))\n                  .join(\"\\n\")\n            }\\n`;\n        }\n\n        return desc;\n    }\n\n    /**\n     * Implementation of Hopcroft's algorithm\n     * https://en.wikipedia.org/wiki/DFA_minimization\n     * @returns {StateMachine} A new {@link StateMachine}\n     */\n    public minimize(): StateMachine {\n        const R = this.reachable();\n        const F = this.setIntersect(this.accepted, R);\n        const Q = this.setIntersect(this.setDiff(new Set(this.nodes()), F), R);\n\n        let P = [F, Q];\n        let W = [F, Q];\n\n        while (W.length > 0) {\n            const A = W.pop()!;\n\n            for (const c of this.alphabet) {\n                const X = new Set<string>();\n\n                for (const transition of this.transitions()) {\n                    const attrs = this.edge(transition);\n                    if (attrs.symbols.includes(c)) {\n                        for (const state of A) {\n                            if (transition.w === state) {\n                                X.add(transition.v);\n                            }\n                        }\n                    }\n                }\n\n                P = P.flatMap(Y => {\n                    const diff = this.setDiff(Y, X);\n                    const intr = this.setIntersect(X, Y);\n                    if (diff.size > 0 && intr.size > 0) {\n                        if (W.includes(Y)) {\n                            W.splice(W.indexOf(Y), 1);\n\n                            W.push(intr, diff);\n                        } else {\n                            W.push(intr.size <= diff.size ? intr : diff);\n                        }\n\n                        return [intr, diff];\n                    } else {\n                        return Y;\n                    }\n                });\n            }\n        }\n\n        const K = P.filter(p => p.size > 0);\n        const names = new Map<string, string>();\n\n        const M = new StateMachine({ multigraph: true });\n\n        K.forEach(k => {\n            const name = [...k].join(\"\");\n            k.forEach(s => names.set(s, name));\n        });\n\n        K.forEach(k => {\n            const s = [...k][0];\n\n            M.setNode(names.get(s)!);\n\n            if (this.accepted.has(s)) {\n                M.setAccepted(names.get(s)!, { peripheries: 2 })\n            }\n\n            (this.outEdges(s) as Edge[]).forEach(e => {\n                this.edge(e).symbols.forEach((c: string) => {\n                    M.setTransition(names.get(s)!, names.get(e.w)!, c);\n                });\n            });\n        });\n\n        M.setInitial(names.get(this.initial)!);\n\n        [...this.alphabet].forEach(c => M.setSymbol(c, {}))\n\n        return M;\n    }\n\n    public testInput(input: string): string | undefined {\n        let node = this.initial;\n\n        for (const c of input) {\n            if (!this.alphabet.has(c)) {\n                return undefined;\n            }\n\n            const edges = this.outEdges(node);\n\n            let found = false;\n            if (edges) {\n                for (const e of edges) {\n                    const edge = this.edge(e);\n\n                    if (edge.symbols.includes(c)) {\n                        node = e.w;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!found) {\n                return node;\n            }\n        }\n\n        return node;\n    }\n\n    private static build(description: StateMachineDescription): StateMachine {\n        const digraph = new StateMachine();\n\n        const { states, initial, accept, alphabet, transitions } = description;\n\n        if (!states) {\n            return digraph;\n        }\n\n        if (!initial) {\n            throw new Error(\"Cannot parse StateMachine with no initial state!\");\n        } else {\n            if (!states.includes(initial)) {\n                throw new Error(\"Initial state set to a state that does not exist!\");\n            }\n        }\n\n        if (accept && accept.length > 0 && accept.some(s => !states.includes(s))) {\n            throw new Error(\"Accepted states includes a state that does not exist!\");\n        }\n\n        if (transitions && transitions.length > 0) {\n            if (!alphabet || alphabet.length === 0) {\n                throw new Error(\"Cannot specify transitions with an empty alphabet!\");\n            }\n\n            if (transitions.some(t => !alphabet.includes(t[1]))) {\n                throw new Error(\"Transition includes a symbol which is not defined in the alphabet!\");\n            }\n\n            if (transitions.some(t => !states.includes(t[0]) || !states.includes(t[2]))) {\n                throw new Error(\"Transition includes a state which is not defined in states!\");\n            }\n        }\n\n        (alphabet || []).forEach(c => digraph.setSymbol(c, {}));\n        states.forEach(s => digraph.setNode(s));\n        digraph.setInitial(initial);\n        (accept || []).forEach(s => digraph.setAccepted(s, { peripheries: 2 }));\n        (transitions || []).forEach(t => digraph.setTransition(t[0], t[2], t[1]));\n\n        return digraph\n    }\n\n    private reachable(): Set<string> {\n        const start = this.initial;\n        const queue = [start];\n        const visited = new Set([start]);\n\n        while (queue.length > 0) {\n            const current = queue.pop();\n\n            for (const transition of this.transitions()) {\n                if (current === transition.v) {\n                    if (!visited.has(transition.w)) {\n                        visited.add(transition.w);\n\n                        if (!queue.includes(transition.w)) {\n                            queue.push(transition.w);\n                        }\n                    }\n                }\n            }\n        }\n\n        return visited;\n    }\n\n    private setDiff<T>(a: Set<T>, b: Set<T>): Set<T> {\n        return new Set([...a].filter(value => !b.has(value)));\n    }\n\n    private setIntersect<T>(a: Set<T>, b: Set<T>): Set<T> {\n        return new Set([...a].filter(value => b.has(value)));\n    }\n}\n\nexport const parse = (input: string): StateMachineDescription => {\n    const initial = parse_initial(input)!;\n    const states = parse_states(input)!;\n    const accept = parse_accepting(input);\n    const alphabet = parse_alphabet(input);\n    const transitions = parse_transitions(input);\n\n    return { initial, states, accept, alphabet, transitions };\n}\n\nconst parse_states = (input: string): string[] | null => {\n    const statesMatch = PATTERNS.STATES.exec(input);\n    return statesMatch && statesMatch[1] ? statesMatch[1].split(/\\s+/).map(s => s.trim()).filter(s => s !== \"\") : null;\n}\n\nconst parse_initial = (input: string): string | null => {\n    const initialMatch = PATTERNS.INITIAL.exec(input);\n\n    return initialMatch && initialMatch[1] ? initialMatch[1] : null;\n}\n\nconst parse_accepting = (input: string): string[] => {\n    const acceptMatch = PATTERNS.ACCEPTING.exec(input);\n    return acceptMatch && acceptMatch[1] ? acceptMatch[1].split(/\\s+/).map(s => s.trim()).filter(s => s !== \"\") : [];\n}\n\nconst parse_alphabet = (input: string): string[] => {\n    const alphabetMatch = PATTERNS.ALPHABET.exec(input);\n    return alphabetMatch && alphabetMatch[1] ? alphabetMatch[1].split(/\\s*/).map(c => c.trim()).filter(c => c !== \"\") : [];\n};\n\nconst parse_transitions = (input: string): [string, string, string][] => {\n    const transMatch = PATTERNS.TRANSITIONS.exec(input);\n\n    if (!transMatch) {\n        return [];\n    }\n\n    return [...transMatch[1].matchAll(/(\\w+)\\s*,\\s*(\\w+)\\s*>\\s*(\\w+)/g)].map(t => {\n        return [t[1], t[2], t[3]];\n    });\n}\n","import React, { FunctionComponent, useState, useEffect } from 'react';\nimport { Graphviz, IGraphvizProps } from 'graphviz-react';\n\nimport dot from \"graphlib-dot\";\nimport {StateMachine, StateMachineDescription} from '../fsm';\n\ninterface Props extends Omit<IGraphvizProps, \"dot\"> { minimize?: boolean; description: string | StateMachineDescription; input?: string | null; }\n\nexport const MachineSimulator: FunctionComponent<Props> = ({ minimize, description, input, ...props }) => {\n    const [error, setError] = useState(\"\");\n    const [parsed, setParsed] = useState<string | null>(null);\n\n    useEffect(() => {\n        try {\n            const graph = StateMachine.parse(description);\n            const fsm = minimize ? graph.minimize() : graph;\n\n            if (input !== null) {\n                const finalNode = fsm.testInput(input || \"\");\n                if (finalNode) {\n                    const node = fsm.node(finalNode);\n                    fsm.setNode(finalNode, { ...node, fillcolor: \"#f54f4c\", style: \"filled\" });\n                }\n            }\n\n            const output = minimize ? dot.write(graph.minimize()) : dot.write(graph);\n            dot.read(output);\n            setParsed(output);\n            setError('');\n        } catch (e) {\n            setError(`${e.name}: ${e.message}`);\n            setParsed(null);\n        }\n\n        return () => {\n            setParsed(null);\n        }\n    }, [description, minimize, input])\n\n    return (\n        parsed ? <Graphviz dot={parsed} {...props}/> : <div>{error}</div>\n    )\n}\n\nMachineSimulator.defaultProps = {\n    minimize: false,\n    input: null\n}\n","import React, {useEffect, useState} from 'react';\nimport {Container, Row, Col, InputGroup, FormControl} from 'react-bootstrap';\n\nimport { MachineSimulator } from '../components';\nimport {StateMachine} from \"../fsm\";\n\nconst DEFAULT_MACHINE = `:states:\na\nb\n:initial:\na\n:accept:\nb\na\n:alphabet:\n0\n1\n:transitions:\na, 0 > b\na, 1 > b\nb, 0 > b\nb, 1 > a`;\n\nexport const Minimizer = () => {\n  const [description, setDescription] = useState<string>(DEFAULT_MACHINE);\n  const [minimized, setMinimized] = useState<string>(\"\");\n  const [hash, setHash] = useState(\"\");\n  const [minimizedHash, setMinimizedHash] = useState(\"\");\n\n    useEffect(() => {\n      try {\n        const base = StateMachine.parse(description);\n        const machine = base.minimize();\n        setMinimized(machine.description());\n        setHash(base.hash());\n        setMinimizedHash(machine.hash());\n      } catch {\n        setMinimized({} as any)\n      }\n    }, [description])\n\n    return (\n        <Container>\n          <h1>DFA Minimizer</h1>\n          <Row>\n            <Col>\n              <Container>\n                <Row>\n                  <h2>Input Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Input</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl value={description} as={\"textarea\"} aria-label=\"input\" onChange={(e) => setDescription(e.target.value)} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <InputGroup style={{ height: \"90px\", width: \"100%\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Hash</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl disabled as={\"textarea\"} aria-label=\"input\" value={hash} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <h2>Input Machine</h2>\n                  <MachineSimulator description={description} options={{ height: 200 }} />\n                </Row>\n              </Container>\n            </Col>\n            <Col>\n              <Container>\n                <Row>\n                  <h2>Minimized Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Input</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl disabled as={\"textarea\"} value={minimized} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <InputGroup style={{ height: \"90px\"}}>\n                    <InputGroup.Prepend>\n                      <InputGroup.Text>Hash</InputGroup.Text>\n                    </InputGroup.Prepend>\n                    <FormControl disabled as={\"textarea\"} aria-label=\"input\" value={minimizedHash} />\n                  </InputGroup>\n                </Row>\n                <br/>\n                <Row>\n                  <h2>Output Machine</h2>\n                  <MachineSimulator description={description} minimize options={{ height: 200 }} />\n                </Row>\n              </Container>\n            </Col>\n          </Row>\n        </Container>\n    )\n}\n","import React, {useEffect, useState} from 'react';\nimport {Container, InputGroup, FormControl, Row, Col} from 'react-bootstrap';\n\nimport { MachineSimulator } from '../components';\nimport {StateMachine} from \"../fsm\";\n\nexport const Simulator = () => {\n    const [description, setDescription] = useState<string>(DEFAULT_MACHINE);\n    const [input, setInput] = useState(\"\");\n    const [accepted, setAccepted] = useState(false);\n    const [hash, setHash] = useState(\"\");\n\n    useEffect(() => {\n        try {\n            const machine = StateMachine.parse(description);\n            setAccepted(machine.isAccepted(input));\n            setHash(machine.hash());\n        } catch {\n            setAccepted(false);\n        }\n    }, [description, input]);\n\n    return (\n      <Container>\n          <h1>DFA Simulator</h1>\n          <Row>\n              <Col>\n                  <h2>Input Description</h2>\n                  <InputGroup style={{ height: \"375px\" }}>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Input</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl as={\"textarea\"} aria-label=\"input\" value={description} onChange={(e) => setDescription(e.target.value)} />\n                  </InputGroup>\n                  <br/>\n                  <InputGroup style={{ height: \"90px\"}}>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Hash</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl disabled as={\"textarea\"} aria-label=\"input\" value={hash} />\n                  </InputGroup>\n              </Col>\n              <Col>\n                  <h2>Simulate Input</h2>\n                  <InputGroup>\n                      <InputGroup.Prepend>\n                          <InputGroup.Text>Input</InputGroup.Text>\n                      </InputGroup.Prepend>\n                      <FormControl aria-label=\"input\" onChange={(e) => setInput(e.target.value)} />\n                  </InputGroup>\n                  <br/>\n                  <h4>Input is {accepted ? \"ACCEPTED\" : \"NOT ACCEPTED\"}.</h4>\n                  <MachineSimulator description={description} input={input} options={{ height: 200 }} />\n              </Col>\n          </Row>\n      </Container>\n    )\n}\n\nconst DEFAULT_MACHINE = `:states:\na\nb\nc\nd\n:initial:\na\n:accept:\nc\n:alphabet:\n0\n1\n:transitions:\na,0>b\na,1>a\nb,0>d\nb,1>c\nc,0>c\nc,1>b\nd,0>d\nd,1>c`;\n","import React from 'react';\r\nimport {Container} from \"react-bootstrap\";\r\nimport {Link} from \"react-router-dom\";\r\n\r\nexport const Home = () => {\r\n  return <Container>\r\n    <h1>FSM Tools</h1>\r\n    <div>\r\n      <div>\r\n        <h2>Simulator</h2>\r\n        <p>Simulate a deterministic finite state machine by visiting the <Link to={\"/simulator\"}>simulator</Link>.</p>\r\n        <h2>Minimizer</h2>\r\n        <p>Minimize a deterministic finite state machine by visiting the <Link to={\"/minimizer\"}>minimizer</Link>.</p>\r\n      </div>\r\n      <h2>Syntax</h2>\r\n      <p>There is a specific syntax for defining machine descriptions.</p>\r\n      <h4>Sections</h4>\r\n      <p>Machine descriptions can contain five sections: states, initial, accept, alphabet, and transitions.</p>\r\n      <div>\r\n        <h5>States</h5>\r\n        <p>The states section is defined as the following:</p>\r\n        <code>\r\n          :states:<br/>\r\n          (alphanumeric string)<br/>\r\n          (alphanumeric string)<br/>\r\n          ...\r\n        </code>\r\n        <br/>\r\n        <br/>\r\n        <p>As an example:</p>\r\n        <code>\r\n          :states:<br/>\r\n          a<br/>\r\n          b<br/>\r\n        </code>\r\n      </div>\r\n      <br/>\r\n      <div>\r\n        <h5>Initial</h5>\r\n        <p>The initial section is defined as an alphanumeric string which is defined in the states section.</p>\r\n        <p>In the case of the example above:</p>\r\n        <code>\r\n          :initial:<br/>\r\n          a\r\n        </code>\r\n      </div>\r\n      <br/>\r\n      <div>\r\n        <h5>Accept</h5>\r\n        <p>The accept section is defined equivalent to the states section, and it must only contain a subset of strings found within the states section.</p>\r\n        <p>In the case of the example above:</p>\r\n        <code>\r\n          :accept:<br/>\r\n          b\r\n        </code>\r\n      </div>\r\n      <br/>\r\n      <div>\r\n        <h5>Alphabet</h5>\r\n        <p>The alphabet section is also defined as states, but is a different set of strings which defines the available transition symbols.</p>\r\n        <p>As an example:</p>\r\n        <code>\r\n          :alphabet:<br/>\r\n          0<br/>\r\n          1\r\n        </code>\r\n      </div>\r\n      <br/>\r\n      <div>\r\n        <h5>Transitions</h5>\r\n        <p>The transitions section is defined as a list of transitions of the form:</p>\r\n        <code>\r\n          :transitions:<br/>\r\n          state, symbol {'>'} state\r\n        </code>\r\n        <br/>\r\n        <br/>\r\n        <p>As an example:</p>\r\n        <code>\r\n          :transitions:<br/>\r\n          a, 0 {'>'} b<br/>\r\n          a, 1  {'>'} b<br/>\r\n          b, 0 {'>'} b<br/>\r\n          b, 1 {'>'} a\r\n        </code>\r\n      </div>\r\n    </div>\r\n  </Container>\r\n};\r\n","import React from 'react';\nimport { Nav, Navbar } from 'react-bootstrap';\n\nimport { BrowserRouter as Router, Link, NavLink, Route, Switch } from \"react-router-dom\";\nimport {Simulator, Minimizer, Home} from './pages';\n\nfunction App() {\n  return (\n    <Router basename={\"/fsm-tools\"}>\n      <header>\n        <Navbar className=\"mx-auto\" style={{ maxWidth: \"1150px\" }} collapseOnSelect expand=\"lg\" variant=\"light\">\n          <Navbar.Brand as={Link} to=\"/\">FSM Tools</Navbar.Brand>\n          <Navbar.Toggle aria-controls=\"responsive-navbar-nav\"/>\n          <Navbar.Collapse id=\"responsive-navbar-nav\">\n              <Nav className=\"mr-auto\">\n                  <Nav.Link className=\"text-secondary\" as={NavLink} to=\"/simulator\">Simulator</Nav.Link>\n                  <Nav.Link className=\"text-secondary\" as={NavLink} to=\"/minimizer\">Minimizer</Nav.Link>\n              </Nav>\n          </Navbar.Collapse>\n        </Navbar>\n      </header>\n      <main>\n        <Switch>\n          <Route path={\"/\"} exact>\n            <Home/>\n          </Route>\n          <Route path=\"/simulator\">\n            <Simulator/>\n          </Route>\n          <Route path=\"/minimizer\">\n            <Minimizer/>\n          </Route>\n        </Switch>\n      </main>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}